---
layout: post
title: 黑客与画家-读后感
category: book
date: 2021-07-24
---

*周末台风，在家重温《黑客与画家》，依然给了我一些感想和启迪。* 如果你也想成为一名hacker，推荐读一读Eric Raymond的[How To Become A Hacker](http://www.catb.org/~esr/faqs/hacker-howto.html)

## 概况

作者Paul Graham是Lisp专家和Y Combinator创始人、创业教父。

    Y Combinator是个技术术语，是创造其他函数的函数

![Paul Graham](/img/paul.webp)

1995年，Paul Graham找到[Robert Morris](https://www.csail.mit.edu/person/robert-morris)（是的，就是“莫里斯蠕虫“”的那个莫里斯）和[Trevor Blackwell](http://tlb.org/)，三个程序员开发了viaweb原型、经历了向投资人展示、拿融资、租新办公室、接受媒体报道、客户变多、被收购赚快钱。随后他还创办了[Y combinator](https://www.ycombinator.com/people/)帮助学生创业（辅导、方法论和价值观等）

Paul的创业哲学：

- 搭建原型
- 上线运营
- 收集反馈
- 调整产品
- 成长壮大

核心是： **Make something people want**

## hacker

- 我们的时代是程序员主导的时代，而伟大的程序员就是hacker，hacker是有精神追求的
- hacker的行为特点： 好玩、高智商、探索精神
- hacker一般不服从管教，叛逆，对强行的规定行为不屑一顾，会找出规避的方法
- hacker真正想做的事是设计优美的软件，而不是完成考核
- 大多数企业不允许hacker做他们想做的事，企业强迫hacker成为程序员，程序员被当作技工，将产品经理的“构想”翻译成代码
- 赚钱的软件往往不是好玩的软件
- hacker如何才能做自己喜欢的事？唯一的方法是找一份养家糊口的白天工作，业余时间开发优美的软件
- hacker不喜欢使用windows，善于写软件的那类人更喜欢使用Linux或FreeBSD
- hacker最好不要做桌面电脑软件，因为这样的话，软件必须能够在windows上运行，而hacker对这个没兴趣，开发互联网软件的话就可以绕过windows，通过浏览器使用即可
- 如果所有软件都运行在服务端，只需要一个浏览器的话，那么你就不需要微软了，也不需要windows了
- 消灭bug是个比较轻松的工作，只有这个时候，编程才是机械的劳动

## 软件工程

- 多人共同开发的正确模式是将项目分割成严格定义的模块，每个模块有清晰的负责人，模块与模块之间的接口经过精心设计，文档要写的清晰
- 《人月神话》表示在软件行业，靠人月堆砌就能快速完成软件是个神话。随着参与人的增加，人与人间需要的沟通呈现指数式增长

## 创业

- 刚开始创业时，你会发现头6个月都在开发，每天工作16个小时，随后会迎接客户，然后就开始沉重的运维工作
- hacker如果创业，有两件事看起来比较费劲，一是不懂企业管理，二是害怕竞争。对于企业管理，只要做出用户喜欢的产品，保证开支小于收入即可，管理经验会慢慢摸索出来；对于二，大公司就像行走的大山，效率迟缓，大公司都是从小公司发展过来的。
- 最顶尖的5%的程序员写出了全世界99%的优秀软件
- 程序员坐在电脑前就能创造财富，优秀软件本身就是有价值的东西

## 工作

- 一个人从小到大，总是从属于某个组织，不管是学校，还是公司。从学校进入到公司，也就从顾客变成了仆人。公司以盈利为目的，公司存在的目的就是满足人们的某种需要。当加入一家公司时，是在和其他人一起合作来满足顾客的需求，可能你自己没有察觉到而已。大学毕业生总是想“我要找个工作”，好像变成某个组织的成员是一件多么重要的事情，**真正重要的事是做出人们需要的东西，而不是加入某个组织**
- 大公司会让每个员工的贡献平均化，大公司无法准确测量每个员工的贡献，大多数时候它只是瞎猜。在大公司里，你只要一般性的努力工作，就能得到意料之中的薪水，但谁也没觉得你会把全部精力投入工作
- 成立公司的目的不是为了奖励那些全部精力投入工作的员工，因为老板已经假定你在全力工作了
- CEO和销售的工作很好测量，拿数字说话就可以了，而普通员工的表现则很难测量
- 工程师实现各种功能，设计师设计一个外形，营销人员将商品卖出去，如何评价每个人的贡献？其实没有办法一一分解清楚，因为始终会被当作一个整体看待，个人的表现无法单独测量。
- 你的工作应该是要可测量的，否则你做的再多，也不会得到更多的回报。CEO是一种同时具备可测量和可放大性的工作

## 小团队

- 小团队天生就适合解决技术难题，因为他们不受官僚主义和繁琐的管理制度的拖累
- 如果你有两个选择，那么就选较难那个，因为你觉得难，别人也会觉得难，就更容易建立技术壁垒
- 大多数时候，促成买方掏钱的方法不是让买家看到获利的可能，而是让他们感到失去机会的恐惧，你的高速成长使得买方未来的收购耗资更大，甚至你的本身会变成他们的一个竞争对手
- 尽快拿出1.0版本，而不是早期过度优化
- 如果得不到报酬，唯一让人愿意做的可能就是，工作必须能提供乐趣。会有人愿意免费写一个软件，但没有人愿意免费提供电话支持，培训

## 编程

- 不同机器语言的指令集基本原理类似，但高级语言不一样，开发程序的模式差别相当大
- 有人说“你用什么语言并不重要，只是工具而已，重要的是你的思想，代码以外的东西才是关键”，这是一派胡言
- 你应该学习Lisp，会让你成为更好的hacker。如果别人用什么技术，你也用什么技术，那么你就只能用windows了。
- 如果开发的是服务器软件，意味着想用什么语言就用什么语言，如果是开发desktop app时，就完全不一样了，只能跟随操作系统所用的开发语言
- 如果一家公司会招聘hacker才会用的编程语言，说明这家公司被hacker控制，有一定的前途；如果招聘上写着笼统的IT名词，说明是个臃肿的大公司
- 在大型组织内部，有一种跟随大多人的选择的做法，叫作“最佳实践”，如果不成功，你就不能指责决策者，因为那是“业界”做出的选择
- 大多数人选择某一种语言，不是因为这种语言有什么独特的特点，而是因为听说其他人使用这种语言

## 产品

- 你只需要不停地重复同一句话，最终人们将会开始倾听
- 新技术被市场接纳的方式有两种：一是自然成长，二是风险资本支持，大肆宣传的大爆炸式增长。最终来看，自然成长会比大爆炸式产生更好的技术。Multicis和Ada就是大爆炸式，而Unix和C是自然成长

## 最后

**保持怀疑精神和想象力**
